	    Stephen Riehm's Bracketing macro system for Vim
	    ===============================================

Last Updated: Wed 29 Jul, 98


    The following description is a little long, for which I
    apologise, but I have great difficulty describing these macros,
    as there is nothing around to compare it with. Please be patient!
    I can't live without these macros, and I know a few other people
    who have made the effort, and who also find them extremely useful.

    Assumption:
	Whenever you type a bracket or quote, you normally want the
	matching bracket or quote as well, and if you forget it, then
	you're going to have problems.

    Solution:
	Whenever you type a bracket, have the editor type the matching
	one for you. (P.S.: mapping these macros directly to the
	characters themselves is a bad idea - use macro names which
	aren't going to be confused with normal text. (think about
	what happens when you cut'n'paste, or things like wanting to
	actually type a singles bracket, ie: <KBD>if( x == "(")</KBD>))

    The system:
    -----------
	Moving "around" brackets and quotes is a pain, so each of the
	bracketing macros leaves a special marker just after the
	closing bracket, so that you can easily jump out of where you
	are. This can be thought of as a mini-form system. The macros
	insert little forms into your text or code, and you then
	simply tab your way through the form and fill out the missing
	bits. (You can also very easily create form-like templates,
	and use the same macros to help you fill them out)

    Two parts:
    ----------
	The system has two parts, the macros for creating the mini
	forms, and the special characters and one macro for jumping
	around in those forms. Both parts are needed for this system
	to work.

    The Macros:
    ===========
	I have found the Meta/Alt Key to be very useful, as vi doesn't
	use them by default, and they very nicely overlap ALL keyboard
	characters. The only problem is recognising them once they've
	been typed, which is why I have commented each macro using the
	M- notation. The following maps can be used in insert mode
	when writing new text, or in visual mode when modifying
	existing text. In visual mode, you highlight the text you want
	to "wrap" and then use the appropriate macro, in insert mode,
	you type the macro and then fill in the middle.

	    Meta-	No-Meta-	Description		Example
	    Macro	Macro
	    -----	--------	-----------		-------
	    Del		Del		jump to next marker
	    M-'		''		Single quotes		'text'
	    M-"		""		Double quotes		"text"
	    M-`		``		Back quotes		`text`
	    M-(		((		Braces, no padding	(text)
	    M-)		))		Braces, with padding	( text )
	    M-[		[[		Brackets, no padding	[text]
	    M-]		]]		Brackets, with padding	[ text ]
	    M-{		{{		Curlies, no padding	{text}
	    M-}		}}		Curlies, NEW BLOCK!
								{
								    text
								}
	    M-<		<<		Angle Brackets		<text>
	    M->		>>		Angle Brackets		< text >
	    M-\		)}		short cut for M-)M-}	( text1 )
								{
								    text2
								}

    And for the HTML fans: (sorry - no support without Meta-keys)
    ------------------------------- -----------------------------
	    M-h		use the last word as		<B>text</B>
			the HTML tag, and create
			matching <> </> for it.
	    M-r		a URL Reference			<A HREF="URL">text</A>
	    M-n		a name				<A NAME="NAME">text</A>

    And for Nroff (man pages):	(sorry - no support without Meta-keys)
    --------------------------	-------- -----------------------------
	    M-fM-b	bold font			\fBtext\fP
	    M-fM-i	italic font			\fItext\fP

    So what have I gained?
    ======================
	The real advantage comes when you are writing code, with lots of
	nesting. Here's a step by step example of a slightly
	complicated "if" statement in a shell script: (The cursor
	position is shown with an * (asterix))

	    You Type:		You Get:
	    ---------		--------
	    if <M-[><M-]>	if [[ * ]«»]«»
	    -f <M-">		if [[ -f "*"«» ]«»]«»
	    $file<Del>		if [[ -f "$file"* ]«»]«»
	     && <M-">		if [[ -f "$file" && "*"«» ]«»]«»
	    $<M-{>		if [[ -f "$file" && "${*}«»"«» ]«»]«»
	    name<Del><Del>	if [[ -f "$file" && "${name}"* ]«»]«»
	     != <M-">		if [[ -f "$file" && "${name}" != "*"«» ]«»]«»
	    Fred<Del><Del><Del>	if [[ -f "$file" && "${name}" != "Fred" ]]*
    

	In typing this example, I didn't have to match any brackets,
	quotes or braces!

	In a similar example, if you want a C-like "if" statement, simply
	type "if <M-\>", and you get:

	    if ( * )
	    {
		«»
	    }«»

	The macro leaves your cursor at the *, in insert mode
	(so you can simply keep typing), and then you just need to hit
	<DEL> to jump into the if block, and <DEL> again gets you out
	of the if block. You can then either hit <ESC> to do something
	else, or <RETURN> to start typing the next statements.

    Did you say "Modeless"?
    =======================
	Well, almost :-)

	Most of these macros are defined for insert mode and visual
	mode. For example: you can insert a new set of quotes when in
	insert mode by using the <M-"> macro, or you can quote 'after
	the fact' by selecting the words you want quoted in visual
	mode, and then hitting <M-">. (It even works on multiple
	lines!)

	The <Del> macro can be used in command mode or in insert mode,
	either way, you jump to the next marker and are left in insert
	mode. You can bounce on the <Del> key to clean up any left
	over markers - when it beeps (leaving you in command mode!)
	there are no more markers in the file. (do you have wrapscan
	turned on too? if not - you might need to go to the top of the
	file and try again to be certain)

    M-} is different!
    =================
	The <M-}> macro also handles formatting. Actually, the <M-}> macro
	uses vim's cindent mode to handle the formatting (which is why
	it will sometimes do strange things with the curlies, but
	normally it gets it right). The beauty is that it also works
	in visual mode. If you had:

	my_function(  )
	{
	    statement1;
	    statement2;
	    statement3;
	    statement4;
	    statement5;
	    statement6;
	    statement7;
	}

	and you want to put statement3, 4, 5 and 6 in an if block, All you
	need to do is type the new if statement over statement3, ie:

	    statement2;
	    if( extra_statements )
	    statement3;

	then highlight the lines which should appear in the new if
	block, in this case from statement3 to statement6, and then type <M-}>,
	you will see something like this:

	my_function(  )
	{
	    statement1;
	    statement2;
	    if( extra_statements )
	    {
		statement3;
		statement4;
		statement5;
		statement6;
	    }
	    statement7;
	}

  
  A quick HTML example
  ====================
	In HTML things are different once again, there you need a
	key-word at the start AND end of most formatting controls. ie:
	a heading: <H1>Heading</H1>. That's easy enough in insert
	mode, the WORD DIRECTLY BEFORE THE CURSOR at the time you use
	the <M-h> macros will be used as the HTML tag! ie: (The cursor
	position is shown with a * (asterix))

	    You Type:		You Get:
	    ---------		--------
	    h1<M-h>		<H1>*</H1>«»
	    Heading<Del>	<H1>Heading</H1>

	or, for paragraphs, lists etc, it gets a little complicated,
	but it's still easier than typing the whole damn lot per hand
	:-)

	    You Type:		You Get:
	    ---------		--------
	    p<M-h>		<P>*</P>«»
	    <Ret><Ret><Up><C-T>	<P>
				    *
				</P>«»
	
	P.S.: <C-T> is vi's way of indenting stuff. Much nicer than
	naked Tabs.

  But there are problems!
  =======================
	Sadly! 'After the fact' html'ifying can't (at the moment)
	prompt you for a html tag to put at the start and end of the
	highlighted text, so you have to do it yourself. Yet another
	'what you type isn't what you get' example, lets have some fun
	with a disfunctional line:

	    disfunctional
	
	no highlight "fun" with vim's visual mode commands, and then
	hit <M-h>, you get (cursor position is shown by the * (asterix))

	    dis<*>fun</«»>ctional

	now all you have to do is fill in the tag at the start and
	end, the following keystrokes will now turn the fun on strong:

	    You type:	strong<Del>strong
	    You get:	dis<strong>fun</strong>ctional

	or, as html would show it: dis_fun_ctional

  Making your own Forms
  =====================
	To create your own forms, use the macro <M-DEL> to insert a new
	jump marker. You can type text between the markers, and this
	text will be printed on the command line when the user jumps
	to that marker. ie:

	    Name:	«user's name»
	    Address:	«user's address»
	    Account:	«user's bank account number :-)»

	For further examples of forms, see the templates/ directory.

  Signoff
  =======
	Well, you should now have an insight as to how these macros
	work together - they are orthogonal, easy to remember, easy to
	type (if you have Meta keys) and quite flexible. They are also
	free, and more or less unsupported. (if you send me an e-mail
	I'll probably answer, but I can't guarantee it!)
	
	Bug fixes, suggestions, comments and improvements are all welcome!

	Enjoy!

(C)opyright: Stephen Riehm 1991 - 1998
sr@pc-plus.de
29.07.98
